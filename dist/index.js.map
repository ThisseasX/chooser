{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import {\r\n  __,\r\n  entries,\r\n  map,\r\n  some,\r\n  has,\r\n  nth,\r\n  partialRight,\r\n  identity,\r\n  values,\r\n  set,\r\n  isFunction,\r\n  isUndefined,\r\n  toString,\r\n  isArray,\r\n  constant,\r\n  flow,\r\n  find,\r\n  eq,\r\n  get,\r\n  pickBy,\r\n  result,\r\n  spread,\r\n  defaultTo,\r\n  isPlainObject,\r\n  negate,\r\n  curryN,\r\n  cond,\r\n  stubTrue,\r\n} from 'lodash/fp';\r\n\r\ntype Choice = {\r\n  when: any;\r\n  then?: any;\r\n  ref?: number;\r\n  use?: any;\r\n  eager?: Function;\r\n};\r\n\r\ntype PlainObject = { [x: string]: any };\r\ntype Choices = Choice[] | PlainObject;\r\ntype LazyChoices = () => Choices;\r\ntype EqualityFn = (input: any, when: any) => boolean;\r\ntype CurriedEqualityFn = (input: any) => (when: any) => boolean;\r\n\r\ntype Args = {\r\n  input: any;\r\n  choices: Choices | LazyChoices;\r\n  equalityFn?: EqualityFn;\r\n};\r\n\r\nconst ARG_PATTERN = /^\\{(?:\\$(\\d+?))?(?:#(.+?))?\\}$/;\r\n\r\nfunction isDefined<T>(x?: T): x is T {\r\n  return negate(isUndefined)(x);\r\n}\r\n\r\n/**\r\n * Converts a simple `PlainObject` entry into a `Choice` object.\r\n *\r\n * @param entry An entry from a `PlainObject` that should be converted into\r\n * a `Choice` object.\r\n */\r\nconst entryToChoice = ([key, value]: [string, any]) =>\r\n  flow(\r\n    ({ when, then }: Choice) => [{ when, then }, ARG_PATTERN.exec(value) || []],\r\n    ([{ when, then }, match]: [Choice, RegExpExecArray]) => ({\r\n      when,\r\n      then,\r\n      ref: match[1],\r\n      use: match[2],\r\n    }),\r\n    pickBy(isDefined),\r\n  )({ when: key, then: value });\r\n\r\n/**\r\n * Transforms a plain object to a `choice` array.\r\n * Keys will be mapped to `when` and values to `then`.\r\n * Values can use the `ref` and `use` shorthand syntax like `'{$0}'` and `'{#one}'`,\r\n * which translates to `{ ref: '0' }` and `{ use: 'one' }` respectively.\r\n *\r\n * @example\r\n * const plain = {\r\n *   one: 1,\r\n *   two: 2,\r\n *   three: '{$1}',\r\n *   four: '{#one}',\r\n * };\r\n *\r\n * const transformed = transformChoiceObjectToArray(plain);\r\n * // =>\r\n * // [\r\n * //   { when: 'one', then: 1 },\r\n * //   { when: 'two', then: 2 },\r\n * //   { when: 'three', ref: '1' },\r\n * //   { when: 'four', use: 'one' },\r\n * // ]\r\n *\r\n * @param choices A plain object.\r\n */\r\nconst transformChoiceObjectToArray = (choices: PlainObject): Choices =>\r\n  flow(\r\n    entries,\r\n    map(entryToChoice)\r\n  )(choices);\r\n\r\n/**\r\n * If the `choices` argument is a plain object, it is transformed into a `choice` array,\r\n * else it is returned as is.\r\n *\r\n * @param choices A `choice` array or a plain object.\r\n */\r\nconst normalizeChoices = (choices: Choices): Choices =>\r\n  isPlainObject(choices)\r\n    ? transformChoiceObjectToArray(choices)\r\n    : choices;\r\n\r\n/**\r\n * If the `choices` argument is a function, it is called so as to extract\r\n * a plain object, or a `choice` array.\r\n *\r\n * @param choices A `choice` array or a plain object, or a function that returns either.\r\n */\r\nconst getChoices = (choices: Choices | LazyChoices): Choices =>\r\n  isFunction(choices)\r\n    ? choices()\r\n    : choices;\r\n\r\n/**\r\n * Transforms the user's input to string when the choices is a plain object and no equalityFn has\r\n * been provided, else returns it as is.\r\n *\r\n * @param choices A `choice` array or a plain object.\r\n * @param input The user's input. Can be anything that will correspond to a `when` value.\r\n */\r\nconst normalizeInput = (\r\n  choices: Choices,\r\n  input: any,\r\n  equalityFn?: EqualityFn,\r\n): any =>\r\n  isPlainObject(choices) && isUndefined(equalityFn)\r\n    ? toString(input)\r\n    : input;\r\n\r\n/**\r\n * Curries the `equalityFn` specified by the user.\r\n *\r\n * @param equalityFn The equalityFn specified by the user.\r\n */\r\nconst normalizeEqualityFn = (\r\n  equalityFn?: EqualityFn,\r\n): CurriedEqualityFn | undefined =>\r\n  equalityFn && curryN<any, any, boolean>(2, equalityFn);\r\n\r\n/**\r\n * Normalizes the library's main args before passing them on.\r\n *\r\n * @param args The library's main args supplied by the user, that will first be normalized.\r\n */\r\nconst normalizeArgs = ({ input, choices, equalityFn }: Args): any[] =>\r\n  flow(\r\n    (args: Args) => set('choices', getChoices(args.choices), args),\r\n    (args: Args) => set('input', normalizeInput(args.choices, args.input, equalityFn), args),\r\n    (args: Args) => set('choices', normalizeChoices(args.choices), args),\r\n    (args: Args) => set('equalityFn', normalizeEqualityFn(equalityFn), args),\r\n    values,\r\n  )({ input, choices, equalityFn });\r\n\r\n/**\r\n * Used to find the desired `choice` among specified `choices`.\r\n *\r\n * The first call partially applies the user's `input` and the specified `equalityFn`.\r\n *\r\n * Returns a predicate that is called with a `choice` and produces a boolean whether it\r\n * matches the user's `input` or not, according to the `equalityFn`.\r\n *\r\n * @param input The user's input. Can be anything that will correspond to a `when` value.\r\n * @param equalityFn Used to check for equality between the user's input and a choice's `when` value.\r\n */\r\nconst matchingChoice = (input: any, equalityFn: CurriedEqualityFn) => (\r\n  choice: Choice,\r\n): boolean =>\r\n  flow(\r\n    get('when'),\r\n    cond<any, boolean>([\r\n      [isArray,\r\n        some(equalityFn(input))],\r\n      [stubTrue,\r\n        equalityFn(input)],\r\n    ]),\r\n  )(choice);\r\n\r\n/**\r\n * Finds a `choice` entry from a `choice` array based on the user's input. It can recursively refer to itself with a\r\n * different index, if a `ref` is specified in the choice.\r\n *\r\n * @param input The user's input. Can be anything that will correspond to a `when` value.\r\n * @param choices A `choice` array or a plain object.\r\n * @param equalityFn Used to override the default equality function `eq` from `lodash`.\r\n * @param index Used to recursively refer to a different choice entry by using a `ref`.\r\n */\r\nconst findChoiceFromArray = (\r\n  input: any,\r\n  choices: Choice[],\r\n  equalityFn: CurriedEqualityFn = eq,\r\n  index?: number,\r\n): Choice =>\r\n  flow(\r\n    cond<Choice[], any>([\r\n      [constant(isDefined(index)),\r\n        nth(<number>index)],\r\n      [stubTrue,\r\n        find(matchingChoice(input, equalityFn))],\r\n    ]),\r\n    defaultTo({}),\r\n    cond<Choice, any>([\r\n      [has('ref'),\r\n        flow(get('ref'), partialRight(findChoiceFromArray, [input, choices, equalityFn, __]))],\r\n      [has('use'),\r\n        flow(get('use'), partialRight(findChoiceFromArray, [__, choices, equalityFn]))],\r\n      [stubTrue,\r\n        identity],\r\n    ]),\r\n  )(choices);\r\n\r\n/**\r\n * The heart of this library, a curried function which stores the specified choices (and extra options) in the first call,\r\n * and returns a function that will take the user's input, find the corresponding choice, and return its `then` value.\r\n *\r\n * It will attempt to resolve it by finding the entry in the `choice` array whose `when` corresponds to the given\r\n * `input`. If a `ref` exists in that entry, it will instead find its referenced entry. IF `use` exists in that entry,\r\n * it will instead try to find an entry that corresponds to the given `use` instead of `when`.\r\n *\r\n * The matching between the `input` and the `when` is performed by running the `equalityFn` with the `input` against the value of `when`,\r\n * or against each element in `when` if it is an array.\r\n *\r\n * After all recursive calls have returned and a choice has been found, the `then` of the choice is returned.\r\n * If the `then` is a function, it is called and its result is returned instead, to leverage lazy evaluation.\r\n *\r\n * As an escape hatch for the above lazy evaluation mechanism, a function can be specified under the `eager` key,\r\n * and it will be returned as is, without it being executed to extract its result.\r\n *\r\n * @param choices A `choice` array or a plain object.\r\n * @param defaultValue A default value to be returned if the `input` does not yield a choice.\r\n * @param equalityFn Used to override the default equality function `eq` from `lodash`.\r\n */\r\nconst chooser = (\r\n  choices: Choices | LazyChoices,\r\n  defaultValue?: any,\r\n  equalityFn?: EqualityFn,\r\n) =>\r\n  /**\r\n   * The function returned by calling `chooser`. Takes user input of any form and tries to match it\r\n   * against a specific `choice` from the `choices` specified in the `chooser` call.\r\n   *\r\n   * It can optionally take an equality function to override the equality function used, just for\r\n   * this call of `choose`.\r\n   *\r\n   * @param input The user's input. Can be anything that will correspond to a `when` value.\r\n   * @param equalityFnOverride Used to override the existing equality function just for this call.\r\n   */\r\n  function choose(input: any, equalityFnOverride?: EqualityFn): any {\r\n    return flow(\r\n      normalizeArgs,\r\n      spread(findChoiceFromArray),\r\n      cond<Choice, any>([\r\n        [has('eager'),\r\n          get('eager')],\r\n        [stubTrue,\r\n          result('then')],\r\n      ]),\r\n      defaultTo(defaultValue),\r\n    )({\r\n      input,\r\n      choices,\r\n      equalityFn: equalityFnOverride || equalityFn,\r\n    });\r\n  };\r\n\r\nexport { chooser };\r\n"],"names":["ARG_PATTERN","isDefined","x","negate","isUndefined","entryToChoice","_a","key","value","flow","when","then","exec","_b","match","ref","use","pickBy","normalizeChoices","choices","isPlainObject","entries","map","transformChoiceObjectToArray","normalizeArgs","input","equalityFn","args","set","isFunction","getChoices","toString","normalizeInput","curryN","normalizeEqualityFn","values","matchingChoice","choice","get","cond","isArray","some","stubTrue","findChoiceFromArray","index","constant","nth","find","defaultTo","has","partialRight","__","identity","defaultValue","equalityFnOverride","spread","result"],"mappings":"+FAmDMA,EAAc,iCAEpB,SAASC,EAAaC,GACpB,OAAOC,SAAOC,cAAPD,CAAoBD,GAS7B,IAAMG,EAAgB,SAACC,OAACC,OAAKC,OAC3B,OAAAC,QACE,SAACH,GAA2B,MAAA,CAAC,CAAEI,YAAMC,aAAQX,EAAYY,KAAKJ,IAAU,OACxE,SAACF,OAACO,OAAEH,SAAMC,SAAQG,OAAsC,OACtDJ,OACAC,OACAI,IAAKD,EAAM,GACXE,IAAKF,EAAM,MAEbG,SAAOhB,GARTQ,CASE,CAAEC,KAAMH,EAAKI,KAAMH,KAuCjBU,EAAmB,SAACC,GACxB,OAAAC,gBAAcD,GAbqB,SAACA,GACpC,OAAAV,OACEY,UACAC,MAAIjB,GAFNI,CAGEU,GAUEI,CAA6BJ,GAC7BA,GA4CAK,EAAgB,SAAClB,OAAEmB,UAAON,YAASO,eACvC,OAAAjB,QACE,SAACkB,GAAe,OAAAC,MAAI,UAtCL,SAACT,GAClB,OAAAU,aAAWV,GACPA,IACAA,EAmC6BW,CAAWH,EAAKR,SAAUQ,MACzD,SAACA,GAAe,OAAAC,MAAI,QA3BD,SACrBT,EACAM,EACAC,GAEA,OAAAN,gBAAcD,IAAYf,cAAYsB,GAClCK,WAASN,GACTA,EAoB2BO,CAAeL,EAAKR,QAASQ,EAAKF,MAAOC,GAAaC,MACnF,SAACA,GAAe,OAAAC,MAAI,UAAWV,EAAiBS,EAAKR,SAAUQ,MAC/D,SAACA,GAAe,OAAAC,MAAI,aAfI,SAC1BF,GAEA,OAAAA,GAAcO,SAA0B,EAAGP,GAYPQ,CAAoBR,GAAaC,KACnEQ,SALF1B,CAME,CAAEgB,QAAON,UAASO,gBAahBU,EAAiB,SAACX,EAAYC,GAAkC,OAAA,SACpEW,GAEA,OAAA5B,OACE6B,MAAI,QACJC,OAAmB,CACjB,CAACC,UACCC,OAAKf,EAAWD,KAClB,CAACiB,WACChB,EAAWD,MANjBhB,CAQE4B,KAWEM,EAAsB,SAC1BlB,EACAN,EACAO,EACAkB,GAEA,oBAHAlB,QAGAjB,OACE8B,OAAoB,CAClB,CAACM,WAAS5C,EAAU2C,IAClBE,MAAYF,IACd,CAACF,WACCK,OAAKX,EAAeX,EAAOC,OAE/BsB,YAAU,IACVT,OAAkB,CAChB,CAACU,MAAI,OACHxC,OAAK6B,MAAI,OAAQY,eAAaP,EAAqB,CAAClB,EAAON,EAASO,EAAYyB,SAClF,CAACF,MAAI,OACHxC,OAAK6B,MAAI,OAAQY,eAAaP,EAAqB,CAACQ,KAAIhC,EAASO,MACnE,CAACgB,WACCU,cAdN3C,CAgBEU,oBAuBY,SACdA,EACAkC,EACA3B,GAYA,OAAA,SAAgBD,EAAY6B,GAC1B,OAAO7C,OACLe,EACA+B,SAAOZ,GACPJ,OAAkB,CAChB,CAACU,MAAI,SACHX,MAAI,UACN,CAACI,WACCc,SAAO,WAEXR,YAAUK,GATL5C,CAUL,CACAgB,QACAN,UACAO,WAAY4B,GAAsB5B"}